<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Réalisation d'un stabilisateur de caméra</title>
    <link rel="stylesheet" href="../../style.css">
    <!-- Prism.js pour la coloration syntaxique -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <style>
        :root { color-scheme: light dark; }
        html, body { height: 100%; margin: 0; }
        body {
            background: #f3f4f6; /* gris clair, proche du site référencé */
            color: #111827;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }
        main {
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 48px 16px;
        }
        .page {
            background: #ffffff;
            color: inherit;
            /* Dimensions A4 à l'écran, avec adaptabilité */
            width: clamp(280px, 90vw, 400mm);
            min-height: 297mm;
            max-width: calc(100vw - 32px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.12);
            border-radius: 6px;
            padding: clamp(24px, 4vw, 32mm) clamp(16px, 3vw, 22mm); /* marges responsives */
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* pas de centrage vertical */
            
        }
        /* Sur petits écrans, préserver le ratio A4 */
        @media (max-width: 800px) {
            .page {
                width: 100%;
                min-height: auto;
                aspect-ratio: 210 / 297;
                padding: 24px;
            }
        }
        h1 {
            font-weight: 700;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0;
            position: absolute;
            text-align: center;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            right: 0;
            max-width: 1000px;
            font-size: clamp(1.6rem, 2.5vw + 1rem, 2.4rem);
            width: 100%;
            height: 60px; /* facultatif, pour mieux centrer verticalement le texte */
        }

        .titre-souligne-gras {
                font-weight: bold;
                text-decoration: underline;
                font-size: 1.15rem;
                margin-top: 2.5rem;
                
                display: inline;
            }  
        .texte{

            font-size: 1.2rem;
            margin-bottom: 2rem;
            color: var(--text-primary);
        }
    
        .page {
            position: relative;
            padding-top: 100px; /* Ajoute de l’espace sous le h1 fixé en haut */
        }

    </style>
    
</head>
<body>
    <main>
        <div class="page">
            <h1 >Réalisation d'un stabilisateur de caméra avec une carte arduino et des composants du commerce</h1>
            <p class="texte" style="margin-top: 4rem">
                Au cours de ma 2ème année de classe préparatoire et dans le cadre de mon TIPE (Travail d'Initiative Personnelle Encadrée), j'ai réalisé une maquette qui reproduit le fonctionnement d'un stabilisateur de caméra sur un axe.
            </p>
            <img src="../../images/projets/maquette un peu penchee.jpg" alt="Maquette stabilisateur - vue penchée" width="30%" height="auto" style="margin-top: 2rem; display: block; margin-left: auto; margin-right: auto;"> 
        
            <span class="titre-souligne-gras">Matériel utilisé :</span>
            <ul style="margin-top: 0.5rem; margin-left: 2rem;">
                <li>Carte Arduino Uno</li>
                <li>Moteur pas à pas 24BYJ48</li>
                <li>2&#215; MPU6050 (module comportant un accéléromètre et un gyroscope)</li>
                <li>Pont en H</li>
            </ul>
            <span style="white-space: nowrap; margin-top:2.5rem">
                <span class="titre-souligne-gras">Fonction réalisée :</span>
                <span class="texte", style = "margin-left : 0.5rem">maintient le plateau bleu (qui modélise la caméra) à l'horizontale</span>
            </span>
            <span class="titre-souligne-gras">Ce que j'ai appris :</span>
            <ul style="margin-top: 0.5rem; margin-left: 2rem;">
                <li>Intérêt et fonctionnement du filtre complémentaire pour l'accéléromètre et le gyroscope</li>
                <li>Fonctionnement et commande du moteur pas à pas en mode pas entiers et demi-pas</li>
            </ul>

        <style>
            .code-block-container {
                background: #262f3d;
                border-radius: 8px;
                padding: 2rem 1.5rem 3rem 1.5rem;
                margin: 2rem auto 2rem auto;
                max-width: 95vw;
                width: 100%;
                box-shadow: 0 2px 24px rgba(0, 0, 0, 0.10);
                color: #f4f4f4;
                position: relative;
                font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
                overflow-x: auto;
            }
            .code-block-container pre {
                margin: 0;
                background: transparent;
                color: #f4f4f4;
                font-size: 0.95rem;
                line-height: 1.6;
                padding: 0;
            }
            .code-block-header {
                font-size: 1.05rem;
                color: #85bfff;
                font-weight: 600;
                margin-bottom: 0.75rem;
                letter-spacing: 0.04em;
            }
            
            /* Styles Prism personnalisés */
            .code-block-container pre[class*="language-"] {
                background: #262f3d !important;
                border-radius: 0;
            }
            
            .code-block-container code[class*="language-"] {
                background: transparent !important;
                color: #e2e8f0 !important;
            }
            
            /* Couleurs spécifiques pour C++ */
            .code-block-container .token.comment {
                color: #68d391 !important;
                font-style: italic;
            }
            
            .code-block-container .token.keyword {
                color: #f687b3 !important;
                font-weight: bold;
            }
            
            .code-block-container .token.string {
                color: #fbb6ce !important;
            }
            
            .code-block-container .token.number {
                color: #f6ad55 !important;
            }
            
            .code-block-container .token.function {
                color: #90cdf4 !important;
            }
            
            .code-block-container .token.class-name {
                color: #fbb6ce !important;
            }
            
            .code-block-container .token.operator {
                color: #f687b3 !important;
            }
            
            .code-block-container .token.punctuation {
                color: #e2e8f0 !important;
            }
            
            /* Styles pour les numéros de ligne Prism */
            .code-block-container pre[class*="line-numbers"] {
                padding-left: 3.8em !important;
            }
            
            .code-block-container .line-numbers .line-numbers-rows {
                border-right: 1px solid #4a5568;
            }
            
            .code-block-container .line-numbers .line-numbers-rows > span:before {
                color: #718096 !important;
            }
            
            /* Styles pour le bouton de déroulement */
            .expand-button {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: #4a5568;
                color: #e2e8f0;
                border: none;
                border-radius: 0 0 8px 8px;
                padding: 0.75rem 1rem;
                cursor: pointer;
                font-size: 0.9rem;
                transition: all 0.3s ease;
                z-index: 10;
                width: 100%;
                text-align: center;
                font-weight: 500;
            }
            
            .expand-button:hover {
                background: #2d3748;
            }
            
            .expand-button.expanded {
                background: #2b6cb0;
            }
            
            .expand-button.expanded:hover {
                background: #2c5282;
            }
            
            /* Masquer le code après la ligne 18 */
            .code-hidden {
                display: none !important;
            }
            
            /* Masquer par défaut le code étendu */
            .code-extended {
                display: none !important;
            }
            
            .code-block-container {
                position: relative;
                padding-bottom: 0;
            }
            
            .code-block-container pre {
                position: relative;
                margin-bottom: 0;
            }
        </style>

        <div class="code-block-container">
            <div class="code-block-header">Code arduino</div>
            <button class="expand-button" onclick="toggleCode()">▼ Voir plus</button>
            <pre class="line-numbers"><code class="language-cpp">#include "Wire.h"  // bibliothèque Wire 
#include "I2Cdev.h"  //bibliothèque I2Cdev 
#include "MPU6050.h" //bibliothèque MPU6050 
MPU6050 accelgyro1(0x69); //définition de l'adresse I2C associée au capteur 1
MPU6050 accelgyro2(0x68); //définition de l'adresse I2C associée au capteur 2
 
//Variables acquisition de theta1 (boîte)
int16_t ax1, ay1, az1;  //accélérations linéaires brutes
int16_t gx1, gy1, gz1;  //vitesses de rotation brutes à diviser par la sensibilité 
float theta_1_gyro=0;
float tehta_1_accel=0;
float theta_1_filtre=0;
float offset1 = -0.00526; //offset pour empecher la dérive du gyroscope 1

// Variables acquisition de theta2 (plateau)
int16_t az2, ax2, ay2 ;  //accélérations linéaires brutes
int16_t gz2, gx2, gy2 ;  //vitesses de rotation brutes à diviser par la sensibilité 

</code></pre>
            
<!-- Code masqué -->
<div id="hidden-code" style="display: none;">
    <pre class="line-numbers"><code class="language-cpp">
float angle_gyro2;
float theta_2_accel=0;
float theta_2_filtre;
float offset2 = 0.057; //offset pour empecher la dérive du gyroscope 2

float K=0.03; //constante pour le filtre comlémentaire


//Variables consigne angulaire
float ecart;
float consigne = 0; //Position angulaire autour de laquelle on cherche à se stabiliser (0° pour être à l'horizontale)
float seuil = 360*4/1024; //angele qui correspond à 4 pas = 1.4°

//Variables moteur 
const int pinBobine1A = 8 ;
const int pinBobine1B = 9 ;
const int pinBobine2A = 10 ;
const int pinBobine2B = 11 ;
float Tps =4;//délai entre chaque pas (4ms en pas entiers, 2ms en demi pas)
float dt = 4*Tps;//durée de chaque tour de boucle (16ms en pas entiers, 8*Tps = 16ms en demi pas)

unsigned long temps;//variable d'acquisition du temps pour python


void setup() {

accelgyro.initialize();  // initialisation du gyroscope 1
accelgyro2.initialize();  // initialisation du gyroscope 2

pinMode(pinBobine1A, OUTPUT); //définition des sorties pour le moteur
pinMode(piBobine1B, OUTPUT); // 
pinMode(piBobine2A, OUTPUT); // 
pinMode(piBobine2B, OUTPUT); //
}

void loop() {

    accelgyro1.getMotion6(&ax1, &ay1, &az1, &gx1, &gy1, &gz1); //accélérations linéaires et vitesses angulaires brutes du capteur 1
    accelgyro2.getMotion6(&az2,&ax2, &ay2, &gz2, &gx2, &gy2); //Permutations des axes d'origine pour respecter le paramétrage

    //acquisition de l'angle du manche (pour affichage seulement)    
    theta_1_accel = atan2((double)ax1,(double)ay1)*180/PI;  //Arctan(ax1/ay1) et 180/PI permet d'avoir l'angle en degré (double : variable locale)
    theta_1_filtre= K*theta_1_accel + (1-K)*(theta_1_filtre + offset1 +float(gz1)*dt/65.5); // 65.5 cf doc MPU6050, dt en s 

    //acquisition de l'angle du plateau (caméra)
    theta_2_accel = atan2((double)ax2,(double)ay2)*180/PI; 
    theta_2_filtre= K*theta_2_acel + (1-K)*(theta_2_filtre + offset2 +float(gz2)*dt/65.5); 

    ecart = consigne - theta_2_filtre; //écart angulaire de la caméra avec l'horizontale

    if (ecart>seuil){
        pas_entier_sens_horaire(); //ou demi_pas_sens_horaire();
    }
    else if (ecart<-1*seuil){ //ou demi_pas_sens_trigo();
        pas_entier_sens_trigo();
    }
    else{
        delay(4*Tps);
    }
    }
    
    void pas_entier_sens_horaire(){
    // Pas n°1 |
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(piBobine1B, LOW);   
    digitalWrite(piBobine2A, HIGH);
    digitalWrite(piBobine2B, LOW);
    delay(Tps); 


    // Pas n°2 |
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(piBobine1B, LOW);  
    digitalWrite(piBobine2A, LOW);
    digitalWrite(piBobine2B, LOW);
    delay(Tps); 

    // Pas n°3 |
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(piBobine1B, LOW);   
    digitalWrite(piBobine2A, LOW);
    digitalWrite(piBobine2B, HIGH);
    delay(Tps); 

    // Pas n°4 |
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(piBobine1B, HIGH);  
    digitalWrite(piBobine2A, LOW);
    digitalWrite(piBobine2B, LOW);
    delay(Tps); 
}    


void pas_entier_sens_trigo(){
    // Pas n°1 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, HIGH);  
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2B, LOW);
    delay(Tps);

    // Pas n°2 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, LOW);   
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2B, HIGH);
    delay(Tps); 

    // Pas n°3 | 
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(pinBobine1B, LOW);  
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2B, LOW);
    delay(Tps); 

    // Pas n°4 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, LOW);   
    digitalWrite(pinBobine2A, HIGH);
    digitalWrite(pinBobine2B, LOW);
    delay(Tps); 

}

void demi_pas_sens_horaire(){
    // Pas n°1 | 
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(pinBobine1B, LOW);  
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps);

    //Pas n°1.5 |
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(pinBobine1B, LOW);  
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, HIGH);
    delay(Tps);
    // Pas n°2 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, LOW);  
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, HIGH);
    delay(Tps); 
    // Pas n°2.5 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, HIGH);   
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, HIGH);
    delay(Tps); 

    // Pas n°3 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, HIGH);   
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps); 
    // Pas n°3.5 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, HIGH);  
    digitalWrite(pinBobine2A, HIGH);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps); 

    // Pas n°4 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, LOW);   
    digitalWrite(pinBobine2A, HIGH);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps); 

    // Pas n°4.5 | 
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(pinBobine1B, LOW);   
    digitalWrite(pinBobine2A, HIGH);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps); 
    }


void demi_pas_sens_trigo(){
    // Pas n°1 | 
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(pinBobine1B, LOW);  
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps);

    //Pas n°1.5 | 
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(pinBobine1B, LOW);  
    digitalWrite(pinBobine2A, HIGH);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps);

    // Pas n°2 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, LOW);  
    digitalWrite(pinBobine2A, HIGH);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps);

    // Pas n°2.5 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, HIGH);   
    digitalWrite(pinBobine2A, HIGH);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps); 

    // Pas n°3 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, HIGH);   
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, LOW);
    delay(Tps); 
    // Pas n°3.5 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, HIGH);  
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, HIGH);
    delay(Tps); 

    // Pas n°4 | 
    digitalWrite(pinBobine1A, LOW);
    digitalWrite(pinBobine1B, LOW);   
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, HIGH);
    delay(Tps); 

    // Pas n°4.5 | 
    digitalWrite(pinBobine1A, HIGH);
    digitalWrite(pinBobine1B, LOW);   
    digitalWrite(pinBobine2A, LOW);
    digitalWrite(pinBobine2A, HIGH);
    delay(Tps); 
}</code></pre>
            </div>
        </div>
            
        </div>

    </main>
    
    <script>
        // Fonction pour basculer l'affichage du code
        function toggleCode() {
            const hiddenCode = document.getElementById('hidden-code');
            const button = document.querySelector('.expand-button');
            
            if (hiddenCode.style.display === 'none') {
                // Afficher le code masqué
                hiddenCode.style.display = 'block';
                button.textContent = '▲ Voir moins';
                button.classList.add('expanded');
            } else {
                // Masquer le code
                hiddenCode.style.display = 'none';
                button.textContent = '▼ Voir plus';
                button.classList.remove('expanded');
            }
        }
        
        // Initialiser Prism.js après le chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            // S'assurer que le code masqué est bien caché au chargement
            const hiddenCode = document.getElementById('hidden-code');
            if (hiddenCode) {
                hiddenCode.style.display = 'none';
            }
            
            // Initialiser Prism.js
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>


